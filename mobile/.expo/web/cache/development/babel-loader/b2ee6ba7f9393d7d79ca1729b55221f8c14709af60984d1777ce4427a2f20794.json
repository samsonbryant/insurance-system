{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport ReanimatedEventEmitter from \"./ReanimatedEventEmitter\";\nimport AnimatedEvent from \"./reanimated1/core/AnimatedEvent\";\nimport AnimatedNode from \"./reanimated1/core/AnimatedNode\";\nimport AnimatedValue from \"./reanimated1/core/AnimatedValue\";\nimport { createOrReusePropsNode } from \"./reanimated1/core/AnimatedProps\";\nimport WorkletEventHandler from \"./reanimated2/WorkletEventHandler\";\nimport setAndForwardRef from \"./setAndForwardRef\";\nimport invariant from 'fbjs/lib/invariant';\nimport { adaptViewConfig } from \"./ConfigHelper\";\nimport { RNRenderer } from \"./reanimated2/platform-specific/RNRenderer\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar NODE_MAPPING = new Map();\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\nfunction dummyListener() {}\nfunction hasAnimatedNodes(value) {\n  if (value instanceof AnimatedNode) {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.some(function (item) {\n      return hasAnimatedNodes(item);\n    });\n  }\n  if (value && typeof value === 'object') {\n    return Object.keys(value).some(function (key) {\n      return hasAnimatedNodes(value[key]);\n    });\n  }\n  return false;\n}\nfunction flattenArray(array) {\n  if (!Array.isArray(array)) {\n    return array;\n  }\n  var resultArr = [];\n  var _flattenArray2 = function _flattenArray(arr) {\n    arr.forEach(function (item) {\n      if (Array.isArray(item)) {\n        _flattenArray2(item);\n      } else {\n        resultArr.push(item);\n      }\n    });\n  };\n  _flattenArray2(array);\n  return resultArr;\n}\nexport default function createAnimatedComponent(Component) {\n  invariant(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n  var AnimatedComponent = function (_React$Component) {\n    function AnimatedComponent(props) {\n      var _this;\n      _classCallCheck(this, AnimatedComponent);\n      _this = _callSuper(this, AnimatedComponent, [props]);\n      _this._invokeAnimatedPropsCallbackOnMount = false;\n      _this._animatedPropsCallback = function () {\n        if (_this._component == null) {\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else {\n          _this._component.setNativeProps(_this._propsAnimated.__getValue());\n        }\n      };\n      _this._setComponentRef = setAndForwardRef({\n        getForwardedRef: function getForwardedRef() {\n          return _this.props.forwardedRef;\n        },\n        setLocalRef: function setLocalRef(ref) {\n          if (ref !== _this._component) {\n            _this._component = ref;\n          }\n          if (ref != null && ref.getNode == null) {\n            ref.getNode = function () {\n              var _ref$constructor$name;\n              console.warn('%s: Calling %s on the ref of an Animated component ' + 'is no longer necessary. You can now directly use the ref ' + 'instead. This method will be removed in a future release.', (_ref$constructor$name = ref.constructor.name) != null ? _ref$constructor$name : '<<anonymous>>', 'getNode()');\n              return ref;\n            };\n          }\n        }\n      });\n      _this._attachProps(_this.props);\n      if (process.env.JEST_WORKER_ID) {\n        _this.animatedStyle = {\n          value: {}\n        };\n      }\n      return _this;\n    }\n    _inherits(AnimatedComponent, _React$Component);\n    return _createClass(AnimatedComponent, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._detachPropUpdater();\n        this._propsAnimated && this._propsAnimated.__detach();\n        this._detachNativeEvents();\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this._invokeAnimatedPropsCallbackOnMount) {\n          this._invokeAnimatedPropsCallbackOnMount = false;\n          this._animatedPropsCallback();\n        }\n        this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n        this._attachNativeEvents();\n        this._attachPropUpdater();\n        this._attachAnimatedStyles();\n      }\n    }, {\n      key: \"_getEventViewRef\",\n      value: function _getEventViewRef() {\n        return this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n      }\n    }, {\n      key: \"_attachNativeEvents\",\n      value: function _attachNativeEvents() {\n        var node = this._getEventViewRef();\n        var viewTag = findNodeHandle(node);\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof AnimatedEvent) {\n            prop.attachEvent(node, key);\n          } else if (prop != null && prop.current && prop.current instanceof WorkletEventHandler) {\n            prop.current.registerForEvents(viewTag, key);\n          }\n        }\n      }\n    }, {\n      key: \"_detachNativeEvents\",\n      value: function _detachNativeEvents() {\n        var node = this._getEventViewRef();\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof AnimatedEvent) {\n            prop.detachEvent(node, key);\n          } else if (prop != null && prop.current && prop.current instanceof WorkletEventHandler) {\n            prop.current.unregisterFromEvents();\n          }\n        }\n      }\n    }, {\n      key: \"_reattachNativeEvents\",\n      value: function _reattachNativeEvents(prevProps) {\n        var node = this._getEventViewRef();\n        var attached = new Set();\n        var nextEvts = new Set();\n        var viewTag;\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof AnimatedEvent) {\n            nextEvts.add(prop.__nodeID);\n          } else if (prop != null && prop.current && prop.current instanceof WorkletEventHandler) {\n            if (viewTag === undefined) {\n              viewTag = prop.current.viewTag;\n            }\n          }\n        }\n        for (var _key in prevProps) {\n          var _prop = this.props[_key];\n          if (_prop instanceof AnimatedEvent) {\n            if (!nextEvts.has(_prop.__nodeID)) {\n              _prop.detachEvent(node, _key);\n            } else {\n              attached.add(_prop.__nodeID);\n            }\n          } else if (_prop != null && _prop.current && _prop.current instanceof WorkletEventHandler && _prop.current.reattachNeeded) {\n            _prop.current.unregisterFromEvents();\n          }\n        }\n        for (var _key2 in this.props) {\n          var _prop2 = this.props[_key2];\n          if (_prop2 instanceof AnimatedEvent && !attached.has(_prop2.__nodeID)) {\n            _prop2.attachEvent(node, _key2);\n          } else if (_prop2 != null && _prop2.current && _prop2.current instanceof WorkletEventHandler && _prop2.current.reattachNeeded) {\n            _prop2.current.registerForEvents(viewTag, _key2);\n            _prop2.current.reattachNeeded = false;\n          }\n        }\n      }\n    }, {\n      key: \"_attachProps\",\n      value: function _attachProps(nextProps) {\n        var oldPropsAnimated = this._propsAnimated;\n        this._propsAnimated = createOrReusePropsNode(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n        if (oldPropsAnimated !== this._propsAnimated) {\n          oldPropsAnimated && oldPropsAnimated.__detach();\n        }\n      }\n    }, {\n      key: \"_updateFromNative\",\n      value: function _updateFromNative(props) {\n        var _this$_component$setN, _this$_component;\n        (_this$_component$setN = (_this$_component = this._component).setNativeProps) == null ? void 0 : _this$_component$setN.call(_this$_component, props);\n      }\n    }, {\n      key: \"_attachPropUpdater\",\n      value: function _attachPropUpdater() {\n        var viewTag = findNodeHandle(this);\n        NODE_MAPPING.set(viewTag, this);\n        if (NODE_MAPPING.size === 1) {\n          ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n        }\n      }\n    }, {\n      key: \"_attachAnimatedStyles\",\n      value: function _attachAnimatedStyles() {\n        var _this2 = this,\n          _this$props$animatedP;\n        var styles = Array.isArray(this.props.style) ? this.props.style : [this.props.style];\n        styles = flattenArray(styles);\n        var viewTag, viewName;\n        if (Platform.OS === 'web') {\n          viewTag = findNodeHandle(this);\n          viewName = null;\n        } else {\n          var _hostInstance$viewCon;\n          var hostInstance = RNRenderer.findHostInstance_DEPRECATED(this);\n          if (!hostInstance) {\n            throw new Error('Cannot find host instance for this component. Maybe it renders nothing?');\n          }\n          viewTag = hostInstance == null ? void 0 : hostInstance._nativeTag;\n          viewName = hostInstance == null ? void 0 : (_hostInstance$viewCon = hostInstance.viewConfig) == null ? void 0 : _hostInstance$viewCon.uiViewClassName;\n          if (hostInstance && this._hasReanimated2Props(styles) && hostInstance.viewConfig) {\n            adaptViewConfig(hostInstance.viewConfig);\n          }\n        }\n        styles.forEach(function (style) {\n          if (style != null && style.viewDescriptor) {\n            style.viewDescriptor.value = {\n              tag: viewTag,\n              name: viewName\n            };\n            if (process.env.JEST_WORKER_ID) {\n              _this2.animatedStyle.value = _objectSpread(_objectSpread({}, _this2.animatedStyle.value), style.initial);\n              style.animatedStyle.current = _this2.animatedStyle;\n            }\n          }\n        });\n        if ((_this$props$animatedP = this.props.animatedProps) != null && _this$props$animatedP.viewDescriptor) {\n          this.props.animatedProps.viewDescriptor.value = {\n            tag: viewTag,\n            name: viewName\n          };\n        }\n      }\n    }, {\n      key: \"_hasReanimated2Props\",\n      value: function _hasReanimated2Props(flattenStyles) {\n        var _this$props$animatedP2;\n        if ((_this$props$animatedP2 = this.props.animatedProps) != null && _this$props$animatedP2.viewDescriptor) {\n          return true;\n        }\n        if (this.props.style) {\n          for (var style of flattenStyles) {\n            if (style != null && style.hasOwnProperty('viewDescriptor')) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n    }, {\n      key: \"_detachPropUpdater\",\n      value: function _detachPropUpdater() {\n        var viewTag = findNodeHandle(this);\n        NODE_MAPPING.delete(viewTag);\n        if (NODE_MAPPING.size === 0) {\n          ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this._attachProps(this.props);\n        this._reattachNativeEvents(prevProps);\n        this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n      }\n    }, {\n      key: \"_filterNonAnimatedStyle\",\n      value: function _filterNonAnimatedStyle(inputStyle) {\n        var style = {};\n        for (var key in inputStyle) {\n          var value = inputStyle[key];\n          if (!hasAnimatedNodes(value)) {\n            style[key] = value;\n          } else if (value instanceof AnimatedValue) {\n            style[key] = value._startingValue;\n          }\n        }\n        return style;\n      }\n    }, {\n      key: \"_filterNonAnimatedProps\",\n      value: function _filterNonAnimatedProps(inputProps) {\n        var _this3 = this;\n        var props = {};\n        var _loop = function _loop() {\n          var value = inputProps[key];\n          if (key === 'style') {\n            var styles = Array.isArray(value) ? value : [value];\n            var processedStyle = styles.map(function (style) {\n              if (style && style.viewDescriptor) {\n                if (style.viewRef.current === null) {\n                  style.viewRef.current = _this3;\n                }\n                return style.initial;\n              } else {\n                return style;\n              }\n            });\n            props[key] = _this3._filterNonAnimatedStyle(StyleSheet.flatten(processedStyle));\n          } else if (key === 'animatedProps') {\n            Object.keys(value.initial).forEach(function (key) {\n              props[key] = value.initial[key];\n              if (value.viewRef.current === null) {\n                value.viewRef.current = _this3;\n              }\n            });\n          } else if (value instanceof AnimatedEvent) {\n            props[key] = dummyListener;\n          } else if (value != null && value.current && value.current instanceof WorkletEventHandler) {\n            if (value.current.eventNames.length > 0) {\n              value.current.eventNames.forEach(function (eventName) {\n                props[eventName] = value.current.listeners ? value.current.listeners[eventName] : dummyListener;\n              });\n            } else {\n              props[key] = dummyListener;\n            }\n          } else if (!(value instanceof AnimatedNode)) {\n            props[key] = value;\n          } else if (value instanceof AnimatedValue) {\n            props[key] = value._startingValue;\n          }\n        };\n        for (var key in inputProps) {\n          _loop();\n        }\n        return props;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var props = this._filterNonAnimatedProps(this.props);\n        if (process.env.JEST_WORKER_ID) {\n          props.animatedStyle = this.animatedStyle;\n        }\n        var platformProps = Platform.select({\n          web: {},\n          default: {\n            collapsable: false\n          }\n        });\n        return _jsx(Component, _objectSpread(_objectSpread({}, props), {}, {\n          ref: this._setComponentRef\n        }, platformProps));\n      }\n    }]);\n  }(React.Component);\n  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName || Component.name || 'Component'})`;\n  return React.forwardRef(function AnimatedComponentWrapper(props, ref) {\n    return _jsx(AnimatedComponent, _objectSpread(_objectSpread({}, props), ref == null ? null : {\n      forwardedRef: ref\n    }));\n  });\n}","map":{"version":3,"names":["React","findNodeHandle","Platform","StyleSheet","ReanimatedEventEmitter","AnimatedEvent","AnimatedNode","AnimatedValue","createOrReusePropsNode","WorkletEventHandler","setAndForwardRef","invariant","adaptViewConfig","RNRenderer","jsx","_jsx","NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","dummyListener","hasAnimatedNodes","value","Array","isArray","some","item","Object","keys","key","flattenArray","array","resultArr","_flattenArray","arr","forEach","push","createAnimatedComponent","Component","prototype","isReactComponent","AnimatedComponent","_React$Component","_this","_classCallCheck","_callSuper","_invokeAnimatedPropsCallbackOnMount","_animatedPropsCallback","_component","setNativeProps","forceUpdate","_propsAnimated","__getValue","_setComponentRef","getForwardedRef","forwardedRef","setLocalRef","ref","getNode","_ref$constructor$name","console","warn","constructor","name","_attachProps","process","env","JEST_WORKER_ID","animatedStyle","_inherits","_createClass","componentWillUnmount","_detachPropUpdater","__detach","_detachNativeEvents","componentDidMount","setNativeView","_attachNativeEvents","_attachPropUpdater","_attachAnimatedStyles","_getEventViewRef","getScrollableNode","node","prop","attachEvent","current","registerForEvents","detachEvent","unregisterFromEvents","_reattachNativeEvents","prevProps","attached","Set","nextEvts","add","__nodeID","undefined","has","reattachNeeded","nextProps","oldPropsAnimated","_this$_component$setN","_this$_component","call","set","size","addListener","_this2","_this$props$animatedP","styles","style","viewName","OS","_hostInstance$viewCon","hostInstance","findHostInstance_DEPRECATED","Error","_nativeTag","viewConfig","uiViewClassName","_hasReanimated2Props","viewDescriptor","tag","_objectSpread","initial","animatedProps","flattenStyles","_this$props$animatedP2","hasOwnProperty","delete","removeAllListeners","componentDidUpdate","_filterNonAnimatedStyle","inputStyle","_startingValue","_filterNonAnimatedProps","inputProps","_this3","_loop","processedStyle","map","viewRef","flatten","eventNames","length","eventName","listeners","render","platformProps","select","web","default","collapsable","displayName","forwardRef","AnimatedComponentWrapper"],"sources":["/Users/user/Desktop/Insurrance_Verification_System/mobile/node_modules/react-native-reanimated/lib/createAnimatedComponent.js"],"sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './reanimated1/core/AnimatedEvent';\nimport AnimatedNode from './reanimated1/core/AnimatedNode';\nimport AnimatedValue from './reanimated1/core/AnimatedValue';\nimport { createOrReusePropsNode } from './reanimated1/core/AnimatedProps';\nimport WorkletEventHandler from './reanimated2/WorkletEventHandler';\nimport setAndForwardRef from './setAndForwardRef';\n\nimport invariant from 'fbjs/lib/invariant';\nimport { adaptViewConfig } from './ConfigHelper';\nimport { RNRenderer } from './reanimated2/platform-specific/RNRenderer';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nfunction hasAnimatedNodes(value) {\n  if (value instanceof AnimatedNode) {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.some((item) => hasAnimatedNodes(item));\n  }\n  if (value && typeof value === 'object') {\n    return Object.keys(value).some((key) => hasAnimatedNodes(value[key]));\n  }\n  return false;\n}\n\nfunction flattenArray(array) {\n  if (!Array.isArray(array)) {\n    return array;\n  }\n  const resultArr = [];\n\n  const _flattenArray = (arr) => {\n    arr.forEach((item) => {\n      if (Array.isArray(item)) {\n        _flattenArray(item);\n      } else {\n        resultArr.push(item);\n      }\n    });\n  };\n  _flattenArray(array);\n  return resultArr;\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n      if (process.env.JEST_WORKER_ID) {\n        this.animatedStyle = { value: {} };\n      }\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n      this._attachAnimatedStyles();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n      const viewTag = findNodeHandle(node);\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler\n        ) {\n          prop.current.registerForEvents(viewTag, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler\n        ) {\n          prop.current.unregisterFromEvents();\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      let viewTag;\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler\n        ) {\n          if (viewTag === undefined) {\n            viewTag = prop.current.viewTag;\n          }\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler &&\n          prop.current.reattachNeeded\n        ) {\n          prop.current.unregisterFromEvents();\n        }\n      }\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler &&\n          prop.current.reattachNeeded\n        ) {\n          prop.current.registerForEvents(viewTag, key);\n          prop.current.reattachNeeded = false;\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      // eslint-disable-next-line no-unused-expressions\n      this._component.setNativeProps?.(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _attachAnimatedStyles() {\n      let styles = Array.isArray(this.props.style)\n        ? this.props.style\n        : [this.props.style];\n      styles = flattenArray(styles);\n      let viewTag, viewName;\n      if (Platform.OS === 'web') {\n        viewTag = findNodeHandle(this);\n        viewName = null;\n      } else {\n        // hostInstance can be null for a component that doesn't render anything (render function returns null). Example: svg Stop: https://github.com/react-native-svg/react-native-svg/blob/develop/src/elements/Stop.tsx\n        const hostInstance = RNRenderer.findHostInstance_DEPRECATED(this);\n        if (!hostInstance) {\n          throw new Error(\n            'Cannot find host instance for this component. Maybe it renders nothing?'\n          );\n        }\n        // we can access view tag in the same way it's accessed here https://github.com/facebook/react/blob/e3f4eb7272d4ca0ee49f27577156b57eeb07cf73/packages/react-native-renderer/src/ReactFabric.js#L146\n        viewTag = hostInstance?._nativeTag;\n        /**\n         * RN uses viewConfig for components for storing different properties of the component(example: https://github.com/facebook/react-native/blob/master/Libraries/Components/ScrollView/ScrollViewViewConfig.js#L16).\n         * The name we're looking for is in the field named uiViewClassName.\n         */\n        viewName = hostInstance?.viewConfig?.uiViewClassName;\n        // update UI props whitelist for this view\n        if (\n          hostInstance &&\n          this._hasReanimated2Props(styles) &&\n          hostInstance.viewConfig\n        ) {\n          adaptViewConfig(hostInstance.viewConfig);\n        }\n      }\n\n      styles.forEach((style) => {\n        if (style?.viewDescriptor) {\n          style.viewDescriptor.value = { tag: viewTag, name: viewName };\n          if (process.env.JEST_WORKER_ID) {\n            /**\n             * We need to connect Jest's TestObject instance whose contains just props object\n             * with the updateProps() function where we update the properties of the component.\n             * We can't update props object directly because TestObject contains a copy of props - look at render function:\n             * const props = this._filterNonAnimatedProps(this.props);\n             */\n            this.animatedStyle.value = {\n              ...this.animatedStyle.value,\n              ...style.initial,\n            };\n            style.animatedStyle.current = this.animatedStyle;\n          }\n        }\n      });\n      // attach animatedProps property\n      if (this.props.animatedProps?.viewDescriptor) {\n        this.props.animatedProps.viewDescriptor.value = {\n          tag: viewTag,\n          name: viewName,\n        };\n      }\n    }\n\n    _hasReanimated2Props(flattenStyles) {\n      if (this.props.animatedProps?.viewDescriptor) {\n        return true;\n      }\n      if (this.props.style) {\n        for (const style of flattenStyles) {\n          // eslint-disable-next-line no-prototype-builtins\n          if (style?.hasOwnProperty('viewDescriptor')) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = setAndForwardRef({\n      getForwardedRef: () => this.props.forwardedRef,\n      setLocalRef: (ref) => {\n        if (ref !== this._component) {\n          this._component = ref;\n        }\n\n        // TODO: Delete this after React Native also deletes this deprecation helper.\n        if (ref != null && ref.getNode == null) {\n          ref.getNode = () => {\n            console.warn(\n              '%s: Calling %s on the ref of an Animated component ' +\n                'is no longer necessary. You can now directly use the ref ' +\n                'instead. This method will be removed in a future release.',\n              ref.constructor.name ?? '<<anonymous>>',\n              'getNode()'\n            );\n            return ref;\n          };\n        }\n      },\n    });\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (!hasAnimatedNodes(value)) {\n          style[key] = value;\n        } else if (value instanceof AnimatedValue) {\n          // if any style in animated component is set directly to the `Value` we set those styles to the first value of `Value` node in order\n          // to avoid flash of default styles when `Value` is being asynchrounously sent via bridge and initialized in the native side.\n          style[key] = value._startingValue;\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          const styles = Array.isArray(value) ? value : [value];\n          const processedStyle = styles.map((style) => {\n            if (style && style.viewDescriptor) {\n              // this is how we recognize styles returned by useAnimatedStyle\n              if (style.viewRef.current === null) {\n                style.viewRef.current = this;\n              }\n              return style.initial;\n            } else {\n              return style;\n            }\n          });\n          props[key] = this._filterNonAnimatedStyle(\n            StyleSheet.flatten(processedStyle)\n          );\n        } else if (key === 'animatedProps') {\n          Object.keys(value.initial).forEach((key) => {\n            props[key] = value.initial[key];\n            if (value.viewRef.current === null) {\n              value.viewRef.current = this;\n            }\n          });\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (\n          value?.current &&\n          value.current instanceof WorkletEventHandler\n        ) {\n          if (value.current.eventNames.length > 0) {\n            value.current.eventNames.forEach((eventName) => {\n              props[eventName] = value.current.listeners\n                ? value.current.listeners[eventName]\n                : dummyListener;\n            });\n          } else {\n            props[key] = dummyListener;\n          }\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        } else if (value instanceof AnimatedValue) {\n          // if any prop in animated component is set directly to the `Value` we set those props to the first value of `Value` node in order\n          // to avoid default values for a short moment when `Value` is being asynchrounously sent via bridge and initialized in the native side.\n          props[key] = value._startingValue;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      if (process.env.JEST_WORKER_ID) {\n        props.animatedStyle = this.animatedStyle;\n      }\n\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${\n    Component.displayName || Component.name || 'Component'\n  })`;\n\n  return React.forwardRef(function AnimatedComponentWrapper(props, ref) {\n    return (\n      <AnimatedComponent\n        {...props}\n        {...(ref == null ? null : { forwardedRef: ref })}\n      />\n    );\n  });\n}\n"],"mappings":";;;;;;;;;;AAAA,OAAOA,KAAK,MAAM,OAAO;AAAC,OAAAC,cAAA;AAAA,OAAAC,QAAA;AAAA,OAAAC,UAAA;AAE1B,OAAOC,sBAAsB;AAE7B,OAAOC,aAAa;AACpB,OAAOC,YAAY;AACnB,OAAOC,aAAa;AACpB,SAASC,sBAAsB;AAC/B,OAAOC,mBAAmB;AAC1B,OAAOC,gBAAgB;AAEvB,OAAOC,SAAS,MAAM,oBAAoB;AAC1C,SAASC,eAAe;AACxB,SAASC,UAAU;AAAqD,SAAAC,GAAA,IAAAC,IAAA;AAExE,IAAMC,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC;AAE9B,SAASC,QAAQA,CAACC,IAAI,EAAE;EACtB,IAAMC,SAAS,GAAGJ,YAAY,CAACK,GAAG,CAACF,IAAI,CAACG,OAAO,CAAC;EAChDF,SAAS,IAAIA,SAAS,CAACG,iBAAiB,CAACJ,IAAI,CAACK,KAAK,CAAC;AACtD;AAEA,SAASC,aAAaA,CAAA,EAAG,CAGzB;AAEA,SAASC,gBAAgBA,CAACC,KAAK,EAAE;EAC/B,IAAIA,KAAK,YAAYrB,YAAY,EAAE;IACjC,OAAO,IAAI;EACb;EACA,IAAIsB,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACxB,OAAOA,KAAK,CAACG,IAAI,CAAC,UAACC,IAAI;MAAA,OAAKL,gBAAgB,CAACK,IAAI,CAAC;IAAA,EAAC;EACrD;EACA,IAAIJ,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IACtC,OAAOK,MAAM,CAACC,IAAI,CAACN,KAAK,CAAC,CAACG,IAAI,CAAC,UAACI,GAAG;MAAA,OAAKR,gBAAgB,CAACC,KAAK,CAACO,GAAG,CAAC,CAAC;IAAA,EAAC;EACvE;EACA,OAAO,KAAK;AACd;AAEA,SAASC,YAAYA,CAACC,KAAK,EAAE;EAC3B,IAAI,CAACR,KAAK,CAACC,OAAO,CAACO,KAAK,CAAC,EAAE;IACzB,OAAOA,KAAK;EACd;EACA,IAAMC,SAAS,GAAG,EAAE;EAEpB,IAAMC,cAAa,GAAG,SAAhBA,aAAaA,CAAIC,GAAG,EAAK;IAC7BA,GAAG,CAACC,OAAO,CAAC,UAACT,IAAI,EAAK;MACpB,IAAIH,KAAK,CAACC,OAAO,CAACE,IAAI,CAAC,EAAE;QACvBO,cAAa,CAACP,IAAI,CAAC;MACrB,CAAC,MAAM;QACLM,SAAS,CAACI,IAAI,CAACV,IAAI,CAAC;MACtB;IACF,CAAC,CAAC;EACJ,CAAC;EACDO,cAAa,CAACF,KAAK,CAAC;EACpB,OAAOC,SAAS;AAClB;AAEA,eAAe,SAASK,uBAAuBA,CAACC,SAAS,EAAE;EACzDhC,SAAS,CACP,OAAOgC,SAAS,KAAK,UAAU,IAC5BA,SAAS,CAACC,SAAS,IAAID,SAAS,CAACC,SAAS,CAACC,gBAAiB,EAC/D,8EAA8E,GAC5E,gCACJ,CAAC;EAAC,IAEIC,iBAAiB,aAAAC,gBAAA;IAGrB,SAAAD,kBAAYtB,KAAK,EAAE;MAAA,IAAAwB,KAAA;MAAAC,eAAA,OAAAH,iBAAA;MACjBE,KAAA,GAAAE,UAAA,OAAAJ,iBAAA,GAAMtB,KAAK;MAAEwB,KAAA,CAHfG,mCAAmC,GAAG,KAAK;MAAAH,KAAA,CAgI3CI,sBAAsB,GAAG,YAAM;QAC7B,IAAIJ,KAAA,CAAKK,UAAU,IAAI,IAAI,EAAE;UAM3BL,KAAA,CAAKG,mCAAmC,GAAG,IAAI;QACjD,CAAC,MAAM,IAAI,OAAOH,KAAA,CAAKK,UAAU,CAACC,cAAc,KAAK,UAAU,EAAE;UAC/DN,KAAA,CAAKO,WAAW,CAAC,CAAC;QACpB,CAAC,MAAM;UACLP,KAAA,CAAKK,UAAU,CAACC,cAAc,CAACN,KAAA,CAAKQ,cAAc,CAACC,UAAU,CAAC,CAAC,CAAC;QAClE;MACF,CAAC;MAAAT,KAAA,CAgIDU,gBAAgB,GAAGhD,gBAAgB,CAAC;QAClCiD,eAAe,EAAE,SAAjBA,eAAeA,CAAA;UAAA,OAAQX,KAAA,CAAKxB,KAAK,CAACoC,YAAY;QAAA;QAC9CC,WAAW,EAAE,SAAbA,WAAWA,CAAGC,GAAG,EAAK;UACpB,IAAIA,GAAG,KAAKd,KAAA,CAAKK,UAAU,EAAE;YAC3BL,KAAA,CAAKK,UAAU,GAAGS,GAAG;UACvB;UAGA,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACC,OAAO,IAAI,IAAI,EAAE;YACtCD,GAAG,CAACC,OAAO,GAAG,YAAM;cAAA,IAAAC,qBAAA;cAClBC,OAAO,CAACC,IAAI,CACV,qDAAqD,GACnD,2DAA2D,GAC3D,2DAA2D,GAAAF,qBAAA,GAC7DF,GAAG,CAACK,WAAW,CAACC,IAAI,YAAAJ,qBAAA,GAAI,eAAe,EACvC,WACF,CAAC;cACD,OAAOF,GAAG;YACZ,CAAC;UACH;QACF;MACF,CAAC,CAAC;MA9RAd,KAAA,CAAKqB,YAAY,CAACrB,KAAA,CAAKxB,KAAK,CAAC;MAC7B,IAAI8C,OAAO,CAACC,GAAG,CAACC,cAAc,EAAE;QAC9BxB,KAAA,CAAKyB,aAAa,GAAG;UAAE9C,KAAK,EAAE,CAAC;QAAE,CAAC;MACpC;MAAC,OAAAqB,KAAA;IACH;IAAC0B,SAAA,CAAA5B,iBAAA,EAAAC,gBAAA;IAAA,OAAA4B,YAAA,CAAA7B,iBAAA;MAAAZ,GAAA;MAAAP,KAAA,EAED,SAAAiD,oBAAoBA,CAAA,EAAG;QACrB,IAAI,CAACC,kBAAkB,CAAC,CAAC;QACzB,IAAI,CAACrB,cAAc,IAAI,IAAI,CAACA,cAAc,CAACsB,QAAQ,CAAC,CAAC;QACrD,IAAI,CAACC,mBAAmB,CAAC,CAAC;MAC5B;IAAC;MAAA7C,GAAA;MAAAP,KAAA,EAED,SAAAqD,iBAAiBA,CAAA,EAAG;QAClB,IAAI,IAAI,CAAC7B,mCAAmC,EAAE;UAC5C,IAAI,CAACA,mCAAmC,GAAG,KAAK;UAChD,IAAI,CAACC,sBAAsB,CAAC,CAAC;QAC/B;QAEA,IAAI,CAACI,cAAc,IAAI,IAAI,CAACA,cAAc,CAACyB,aAAa,CAAC,IAAI,CAAC5B,UAAU,CAAC;QACzE,IAAI,CAAC6B,mBAAmB,CAAC,CAAC;QAC1B,IAAI,CAACC,kBAAkB,CAAC,CAAC;QACzB,IAAI,CAACC,qBAAqB,CAAC,CAAC;MAC9B;IAAC;MAAAlD,GAAA;MAAAP,KAAA,EAED,SAAA0D,gBAAgBA,CAAA,EAAG;QAGjB,OAAO,IAAI,CAAChC,UAAU,CAACiC,iBAAiB,GACpC,IAAI,CAACjC,UAAU,CAACiC,iBAAiB,CAAC,CAAC,GACnC,IAAI,CAACjC,UAAU;MACrB;IAAC;MAAAnB,GAAA;MAAAP,KAAA,EAED,SAAAuD,mBAAmBA,CAAA,EAAG;QACpB,IAAMK,IAAI,GAAG,IAAI,CAACF,gBAAgB,CAAC,CAAC;QACpC,IAAM/D,OAAO,GAAGrB,cAAc,CAACsF,IAAI,CAAC;QAEpC,KAAK,IAAMrD,GAAG,IAAI,IAAI,CAACV,KAAK,EAAE;UAC5B,IAAMgE,IAAI,GAAG,IAAI,CAAChE,KAAK,CAACU,GAAG,CAAC;UAC5B,IAAIsD,IAAI,YAAYnF,aAAa,EAAE;YACjCmF,IAAI,CAACC,WAAW,CAACF,IAAI,EAAErD,GAAG,CAAC;UAC7B,CAAC,MAAM,IACLsD,IAAI,YAAJA,IAAI,CAAEE,OAAO,IACbF,IAAI,CAACE,OAAO,YAAYjF,mBAAmB,EAC3C;YACA+E,IAAI,CAACE,OAAO,CAACC,iBAAiB,CAACrE,OAAO,EAAEY,GAAG,CAAC;UAC9C;QACF;MACF;IAAC;MAAAA,GAAA;MAAAP,KAAA,EAED,SAAAoD,mBAAmBA,CAAA,EAAG;QACpB,IAAMQ,IAAI,GAAG,IAAI,CAACF,gBAAgB,CAAC,CAAC;QAEpC,KAAK,IAAMnD,GAAG,IAAI,IAAI,CAACV,KAAK,EAAE;UAC5B,IAAMgE,IAAI,GAAG,IAAI,CAAChE,KAAK,CAACU,GAAG,CAAC;UAC5B,IAAIsD,IAAI,YAAYnF,aAAa,EAAE;YACjCmF,IAAI,CAACI,WAAW,CAACL,IAAI,EAAErD,GAAG,CAAC;UAC7B,CAAC,MAAM,IACLsD,IAAI,YAAJA,IAAI,CAAEE,OAAO,IACbF,IAAI,CAACE,OAAO,YAAYjF,mBAAmB,EAC3C;YACA+E,IAAI,CAACE,OAAO,CAACG,oBAAoB,CAAC,CAAC;UACrC;QACF;MACF;IAAC;MAAA3D,GAAA;MAAAP,KAAA,EAED,SAAAmE,qBAAqBA,CAACC,SAAS,EAAE;QAC/B,IAAMR,IAAI,GAAG,IAAI,CAACF,gBAAgB,CAAC,CAAC;QACpC,IAAMW,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC;QAC1B,IAAMC,QAAQ,GAAG,IAAID,GAAG,CAAC,CAAC;QAC1B,IAAI3E,OAAO;QAEX,KAAK,IAAMY,GAAG,IAAI,IAAI,CAACV,KAAK,EAAE;UAC5B,IAAMgE,IAAI,GAAG,IAAI,CAAChE,KAAK,CAACU,GAAG,CAAC;UAC5B,IAAIsD,IAAI,YAAYnF,aAAa,EAAE;YACjC6F,QAAQ,CAACC,GAAG,CAACX,IAAI,CAACY,QAAQ,CAAC;UAC7B,CAAC,MAAM,IACLZ,IAAI,YAAJA,IAAI,CAAEE,OAAO,IACbF,IAAI,CAACE,OAAO,YAAYjF,mBAAmB,EAC3C;YACA,IAAIa,OAAO,KAAK+E,SAAS,EAAE;cACzB/E,OAAO,GAAGkE,IAAI,CAACE,OAAO,CAACpE,OAAO;YAChC;UACF;QACF;QACA,KAAK,IAAMY,IAAG,IAAI6D,SAAS,EAAE;UAC3B,IAAMP,KAAI,GAAG,IAAI,CAAChE,KAAK,CAACU,IAAG,CAAC;UAC5B,IAAIsD,KAAI,YAAYnF,aAAa,EAAE;YACjC,IAAI,CAAC6F,QAAQ,CAACI,GAAG,CAACd,KAAI,CAACY,QAAQ,CAAC,EAAE;cAEhCZ,KAAI,CAACI,WAAW,CAACL,IAAI,EAAErD,IAAG,CAAC;YAC7B,CAAC,MAAM;cAEL8D,QAAQ,CAACG,GAAG,CAACX,KAAI,CAACY,QAAQ,CAAC;YAC7B;UACF,CAAC,MAAM,IACLZ,KAAI,YAAJA,KAAI,CAAEE,OAAO,IACbF,KAAI,CAACE,OAAO,YAAYjF,mBAAmB,IAC3C+E,KAAI,CAACE,OAAO,CAACa,cAAc,EAC3B;YACAf,KAAI,CAACE,OAAO,CAACG,oBAAoB,CAAC,CAAC;UACrC;QACF;QAEA,KAAK,IAAM3D,KAAG,IAAI,IAAI,CAACV,KAAK,EAAE;UAC5B,IAAMgE,MAAI,GAAG,IAAI,CAAChE,KAAK,CAACU,KAAG,CAAC;UAC5B,IAAIsD,MAAI,YAAYnF,aAAa,IAAI,CAAC2F,QAAQ,CAACM,GAAG,CAACd,MAAI,CAACY,QAAQ,CAAC,EAAE;YAEjEZ,MAAI,CAACC,WAAW,CAACF,IAAI,EAAErD,KAAG,CAAC;UAC7B,CAAC,MAAM,IACLsD,MAAI,YAAJA,MAAI,CAAEE,OAAO,IACbF,MAAI,CAACE,OAAO,YAAYjF,mBAAmB,IAC3C+E,MAAI,CAACE,OAAO,CAACa,cAAc,EAC3B;YACAf,MAAI,CAACE,OAAO,CAACC,iBAAiB,CAACrE,OAAO,EAAEY,KAAG,CAAC;YAC5CsD,MAAI,CAACE,OAAO,CAACa,cAAc,GAAG,KAAK;UACrC;QACF;MACF;IAAC;MAAArE,GAAA;MAAAP,KAAA,EAsBD,SAAA0C,YAAYA,CAACmC,SAAS,EAAE;QACtB,IAAMC,gBAAgB,GAAG,IAAI,CAACjD,cAAc;QAE5C,IAAI,CAACA,cAAc,GAAGhD,sBAAsB,CAC1CgG,SAAS,EACT,IAAI,CAACpD,sBAAsB,EAC3BqD,gBACF,CAAC;QAED,IAAIA,gBAAgB,KAAK,IAAI,CAACjD,cAAc,EAAE;UAS5CiD,gBAAgB,IAAIA,gBAAgB,CAAC3B,QAAQ,CAAC,CAAC;QACjD;MACF;IAAC;MAAA5C,GAAA;MAAAP,KAAA,EAED,SAAAJ,iBAAiBA,CAACC,KAAK,EAAE;QAAA,IAAAkF,qBAAA,EAAAC,gBAAA;QAEvB,CAAAD,qBAAA,IAAAC,gBAAA,OAAI,CAACtD,UAAU,EAACC,cAAc,qBAA9BoD,qBAAA,CAAAE,IAAA,CAAAD,gBAAA,EAAiCnF,KAAK,CAAC;MACzC;IAAC;MAAAU,GAAA;MAAAP,KAAA,EAED,SAAAwD,kBAAkBA,CAAA,EAAG;QACnB,IAAM7D,OAAO,GAAGrB,cAAc,CAAC,IAAI,CAAC;QACpCe,YAAY,CAAC6F,GAAG,CAACvF,OAAO,EAAE,IAAI,CAAC;QAC/B,IAAIN,YAAY,CAAC8F,IAAI,KAAK,CAAC,EAAE;UAC3B1G,sBAAsB,CAAC2G,WAAW,CAAC,yBAAyB,EAAE7F,QAAQ,CAAC;QACzE;MACF;IAAC;MAAAgB,GAAA;MAAAP,KAAA,EAED,SAAAyD,qBAAqBA,CAAA,EAAG;QAAA,IAAA4B,MAAA;UAAAC,qBAAA;QACtB,IAAIC,MAAM,GAAGtF,KAAK,CAACC,OAAO,CAAC,IAAI,CAACL,KAAK,CAAC2F,KAAK,CAAC,GACxC,IAAI,CAAC3F,KAAK,CAAC2F,KAAK,GAChB,CAAC,IAAI,CAAC3F,KAAK,CAAC2F,KAAK,CAAC;QACtBD,MAAM,GAAG/E,YAAY,CAAC+E,MAAM,CAAC;QAC7B,IAAI5F,OAAO,EAAE8F,QAAQ;QACrB,IAAIlH,QAAQ,CAACmH,EAAE,KAAK,KAAK,EAAE;UACzB/F,OAAO,GAAGrB,cAAc,CAAC,IAAI,CAAC;UAC9BmH,QAAQ,GAAG,IAAI;QACjB,CAAC,MAAM;UAAA,IAAAE,qBAAA;UAEL,IAAMC,YAAY,GAAG1G,UAAU,CAAC2G,2BAA2B,CAAC,IAAI,CAAC;UACjE,IAAI,CAACD,YAAY,EAAE;YACjB,MAAM,IAAIE,KAAK,CACb,yEACF,CAAC;UACH;UAEAnG,OAAO,GAAGiG,YAAY,oBAAZA,YAAY,CAAEG,UAAU;UAKlCN,QAAQ,GAAGG,YAAY,qBAAAD,qBAAA,GAAZC,YAAY,CAAEI,UAAU,qBAAxBL,qBAAA,CAA0BM,eAAe;UAEpD,IACEL,YAAY,IACZ,IAAI,CAACM,oBAAoB,CAACX,MAAM,CAAC,IACjCK,YAAY,CAACI,UAAU,EACvB;YACA/G,eAAe,CAAC2G,YAAY,CAACI,UAAU,CAAC;UAC1C;QACF;QAEAT,MAAM,CAAC1E,OAAO,CAAC,UAAC2E,KAAK,EAAK;UACxB,IAAIA,KAAK,YAALA,KAAK,CAAEW,cAAc,EAAE;YACzBX,KAAK,CAACW,cAAc,CAACnG,KAAK,GAAG;cAAEoG,GAAG,EAAEzG,OAAO;cAAE8C,IAAI,EAAEgD;YAAS,CAAC;YAC7D,IAAI9C,OAAO,CAACC,GAAG,CAACC,cAAc,EAAE;cAO9BwC,MAAI,CAACvC,aAAa,CAAC9C,KAAK,GAAAqG,aAAA,CAAAA,aAAA,KACnBhB,MAAI,CAACvC,aAAa,CAAC9C,KAAK,GACxBwF,KAAK,CAACc,OAAO,CACjB;cACDd,KAAK,CAAC1C,aAAa,CAACiB,OAAO,GAAGsB,MAAI,CAACvC,aAAa;YAClD;UACF;QACF,CAAC,CAAC;QAEF,KAAAwC,qBAAA,GAAI,IAAI,CAACzF,KAAK,CAAC0G,aAAa,aAAxBjB,qBAAA,CAA0Ba,cAAc,EAAE;UAC5C,IAAI,CAACtG,KAAK,CAAC0G,aAAa,CAACJ,cAAc,CAACnG,KAAK,GAAG;YAC9CoG,GAAG,EAAEzG,OAAO;YACZ8C,IAAI,EAAEgD;UACR,CAAC;QACH;MACF;IAAC;MAAAlF,GAAA;MAAAP,KAAA,EAED,SAAAkG,oBAAoBA,CAACM,aAAa,EAAE;QAAA,IAAAC,sBAAA;QAClC,KAAAA,sBAAA,GAAI,IAAI,CAAC5G,KAAK,CAAC0G,aAAa,aAAxBE,sBAAA,CAA0BN,cAAc,EAAE;UAC5C,OAAO,IAAI;QACb;QACA,IAAI,IAAI,CAACtG,KAAK,CAAC2F,KAAK,EAAE;UACpB,KAAK,IAAMA,KAAK,IAAIgB,aAAa,EAAE;YAEjC,IAAIhB,KAAK,YAALA,KAAK,CAAEkB,cAAc,CAAC,gBAAgB,CAAC,EAAE;cAC3C,OAAO,IAAI;YACb;UACF;QACF;QACA,OAAO,KAAK;MACd;IAAC;MAAAnG,GAAA;MAAAP,KAAA,EAED,SAAAkD,kBAAkBA,CAAA,EAAG;QACnB,IAAMvD,OAAO,GAAGrB,cAAc,CAAC,IAAI,CAAC;QACpCe,YAAY,CAACsH,MAAM,CAAChH,OAAO,CAAC;QAC5B,IAAIN,YAAY,CAAC8F,IAAI,KAAK,CAAC,EAAE;UAC3B1G,sBAAsB,CAACmI,kBAAkB,CAAC,yBAAyB,CAAC;QACtE;MACF;IAAC;MAAArG,GAAA;MAAAP,KAAA,EAED,SAAA6G,kBAAkBA,CAACzC,SAAS,EAAE;QAC5B,IAAI,CAAC1B,YAAY,CAAC,IAAI,CAAC7C,KAAK,CAAC;QAC7B,IAAI,CAACsE,qBAAqB,CAACC,SAAS,CAAC;QAErC,IAAI,CAACvC,cAAc,IAAI,IAAI,CAACA,cAAc,CAACyB,aAAa,CAAC,IAAI,CAAC5B,UAAU,CAAC;MAC3E;IAAC;MAAAnB,GAAA;MAAAP,KAAA,EAyBD,SAAA8G,uBAAuBA,CAACC,UAAU,EAAE;QAClC,IAAMvB,KAAK,GAAG,CAAC,CAAC;QAChB,KAAK,IAAMjF,GAAG,IAAIwG,UAAU,EAAE;UAC5B,IAAM/G,KAAK,GAAG+G,UAAU,CAACxG,GAAG,CAAC;UAC7B,IAAI,CAACR,gBAAgB,CAACC,KAAK,CAAC,EAAE;YAC5BwF,KAAK,CAACjF,GAAG,CAAC,GAAGP,KAAK;UACpB,CAAC,MAAM,IAAIA,KAAK,YAAYpB,aAAa,EAAE;YAGzC4G,KAAK,CAACjF,GAAG,CAAC,GAAGP,KAAK,CAACgH,cAAc;UACnC;QACF;QACA,OAAOxB,KAAK;MACd;IAAC;MAAAjF,GAAA;MAAAP,KAAA,EAED,SAAAiH,uBAAuBA,CAACC,UAAU,EAAE;QAAA,IAAAC,MAAA;QAClC,IAAMtH,KAAK,GAAG,CAAC,CAAC;QAAC,IAAAuH,KAAA,YAAAA,MAAA,EACa;UAC5B,IAAMpH,KAAK,GAAGkH,UAAU,CAAC3G,GAAG,CAAC;UAC7B,IAAIA,GAAG,KAAK,OAAO,EAAE;YACnB,IAAMgF,MAAM,GAAGtF,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC;YACrD,IAAMqH,cAAc,GAAG9B,MAAM,CAAC+B,GAAG,CAAC,UAAC9B,KAAK,EAAK;cAC3C,IAAIA,KAAK,IAAIA,KAAK,CAACW,cAAc,EAAE;gBAEjC,IAAIX,KAAK,CAAC+B,OAAO,CAACxD,OAAO,KAAK,IAAI,EAAE;kBAClCyB,KAAK,CAAC+B,OAAO,CAACxD,OAAO,GAAGoD,MAAI;gBAC9B;gBACA,OAAO3B,KAAK,CAACc,OAAO;cACtB,CAAC,MAAM;gBACL,OAAOd,KAAK;cACd;YACF,CAAC,CAAC;YACF3F,KAAK,CAACU,GAAG,CAAC,GAAG4G,MAAI,CAACL,uBAAuB,CACvCtI,UAAU,CAACgJ,OAAO,CAACH,cAAc,CACnC,CAAC;UACH,CAAC,MAAM,IAAI9G,GAAG,KAAK,eAAe,EAAE;YAClCF,MAAM,CAACC,IAAI,CAACN,KAAK,CAACsG,OAAO,CAAC,CAACzF,OAAO,CAAC,UAACN,GAAG,EAAK;cAC1CV,KAAK,CAACU,GAAG,CAAC,GAAGP,KAAK,CAACsG,OAAO,CAAC/F,GAAG,CAAC;cAC/B,IAAIP,KAAK,CAACuH,OAAO,CAACxD,OAAO,KAAK,IAAI,EAAE;gBAClC/D,KAAK,CAACuH,OAAO,CAACxD,OAAO,GAAGoD,MAAI;cAC9B;YACF,CAAC,CAAC;UACJ,CAAC,MAAM,IAAInH,KAAK,YAAYtB,aAAa,EAAE;YAKzCmB,KAAK,CAACU,GAAG,CAAC,GAAGT,aAAa;UAC5B,CAAC,MAAM,IACLE,KAAK,YAALA,KAAK,CAAE+D,OAAO,IACd/D,KAAK,CAAC+D,OAAO,YAAYjF,mBAAmB,EAC5C;YACA,IAAIkB,KAAK,CAAC+D,OAAO,CAAC0D,UAAU,CAACC,MAAM,GAAG,CAAC,EAAE;cACvC1H,KAAK,CAAC+D,OAAO,CAAC0D,UAAU,CAAC5G,OAAO,CAAC,UAAC8G,SAAS,EAAK;gBAC9C9H,KAAK,CAAC8H,SAAS,CAAC,GAAG3H,KAAK,CAAC+D,OAAO,CAAC6D,SAAS,GACtC5H,KAAK,CAAC+D,OAAO,CAAC6D,SAAS,CAACD,SAAS,CAAC,GAClC7H,aAAa;cACnB,CAAC,CAAC;YACJ,CAAC,MAAM;cACLD,KAAK,CAACU,GAAG,CAAC,GAAGT,aAAa;YAC5B;UACF,CAAC,MAAM,IAAI,EAAEE,KAAK,YAAYrB,YAAY,CAAC,EAAE;YAC3CkB,KAAK,CAACU,GAAG,CAAC,GAAGP,KAAK;UACpB,CAAC,MAAM,IAAIA,KAAK,YAAYpB,aAAa,EAAE;YAGzCiB,KAAK,CAACU,GAAG,CAAC,GAAGP,KAAK,CAACgH,cAAc;UACnC;QACF,CAAC;QAnDD,KAAK,IAAMzG,GAAG,IAAI2G,UAAU;UAAAE,KAAA;QAAA;QAoD5B,OAAOvH,KAAK;MACd;IAAC;MAAAU,GAAA;MAAAP,KAAA,EAED,SAAA6H,MAAMA,CAAA,EAAG;QACP,IAAMhI,KAAK,GAAG,IAAI,CAACoH,uBAAuB,CAAC,IAAI,CAACpH,KAAK,CAAC;QACtD,IAAI8C,OAAO,CAACC,GAAG,CAACC,cAAc,EAAE;UAC9BhD,KAAK,CAACiD,aAAa,GAAG,IAAI,CAACA,aAAa;QAC1C;QAEA,IAAMgF,aAAa,GAAGvJ,QAAQ,CAACwJ,MAAM,CAAC;UACpCC,GAAG,EAAE,CAAC,CAAC;UACPC,OAAO,EAAE;YAAEC,WAAW,EAAE;UAAM;QAChC,CAAC,CAAC;QACF,OACE9I,IAAA,CAAC4B,SAAS,EAAAqF,aAAA,CAAAA,aAAA,KAAKxG,KAAK;UAAEsC,GAAG,EAAE,IAAI,CAACJ;QAAiB,GAAK+F,aAAa,CAAG,CAAC;MAE3E;IAAC;EAAA,EA1X6BzJ,KAAK,CAAC2C,SAAS;EA6X/CG,iBAAiB,CAACgH,WAAW,GAAG,qBAC9BnH,SAAS,CAACmH,WAAW,IAAInH,SAAS,CAACyB,IAAI,IAAI,WAAW,GACrD;EAEH,OAAOpE,KAAK,CAAC+J,UAAU,CAAC,SAASC,wBAAwBA,CAACxI,KAAK,EAAEsC,GAAG,EAAE;IACpE,OACE/C,IAAA,CAAC+B,iBAAiB,EAAAkF,aAAA,CAAAA,aAAA,KACZxG,KAAK,GACJsC,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG;MAAEF,YAAY,EAAEE;IAAI,CAAC,CAChD,CAAC;EAEN,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}